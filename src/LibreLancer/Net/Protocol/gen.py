# Run with python3 gen.py

import json
from datetime import datetime,timezone

print("Librelancer Protocol Generator 2021-07-14")

# NetPacketReader methods
typeMethods = {
  "int" : "GetInt",
  "Quaternion" : "GetQuaternion",
  "Vector3" : "GetVector3",
  "byte" : "GetByte",
  "sbyte" : "GetSByte",
  "double" : "GetDouble",
  "float" : "GetFloat",
  "long" : "GetLong",
  "IPEndPoint" : "GetNetEndPoint",
  "short" : "GetShort",
  "string" : "GetString",
  "uint" : "GetUInt",
  "ulong" : "GetULong",
  "ushort" : "GetUShort",
  "bool" : "GetBool"
}

# Read the json
with open("protocol.json", "r") as f:
  jstr = f.read()
  
jfile = json.loads(jstr)

# File output code
outfile = open("Protocol.gen.cs", "w")
tabs = 0

def get_indent():
  _indent = ""
  for i in range(tabs):
    _indent = _indent + "    "
  return _indent
    
def writeline(line):
  outfile.write(get_indent())
  outfile.write(line)
  outfile.write("\n")
  
def writestart(line):
  outfile.write(get_indent())
  outfile.write(line)
  
def write(line):
  outfile.write(line)
  
def writeend(line):
  outfile.write(line)
  outfile.write("\n")
 
def whitespace():
  outfile.write("\n")

# Creates a C# method prototype from JSON description
def method_proto(method, _class):
  _proto = ""
  if _class:
    _proto = "public "
  if "return" not in method:
    _proto += "void "
  else:
    _proto += "Task<" + method["return"] + "> "
  _proto = _proto + method["name"] + "("
  if "args" not in method:
    return _proto + ")"
  for idx, a in enumerate(method["args"]):
    _proto += a["type"] + " " + a["name"]
    if idx + 1 < len(method["args"]):
      _proto += ", "
  _proto += ")"
  return _proto

def remote_method(mthd, prefix):
  global tabs
  whitespace()
  writeline(method_proto(mthd, True))
  writeline("{")
  tabs += 1
  if "return" in mthd:
    writeline("var complete = GetCompletionSource_" + mthd["return"] + "(retSeq);")
  writeline("SendPacket(new " + prefix + "Packet_" + mthd["name"] + "() {")
  tabs += 1
  if "return" in mthd:
    writeline("Sequence = retSeq++,")
  if "args" in mthd:
    for x in mthd["args"]:
      writeline(x["name"] + " = " + x["name"] + ",")
  tabs -= 1
  writeline("});")
  if "return" in mthd:
    writeline("return complete.Task;")
  tabs -= 1
  writeline("}")
  


# Header
writeline("// AUTOGENERATED CODE")

writeline("// Generated: " + datetime.now(timezone.utc).strftime("%Y%m%d %H:%M:%S UTC"))
whitespace()
writeline("using System;")
writeline("using System.Threading.Tasks;")
writeline("using LiteNetLib;")
writeline("using LiteNetLib.Utils;")
whitespace()
writeline("namespace LibreLancer.Net")
writeline("{")
tabs += 1
#
# Client Interface
#
writeline("public interface IClientPlayer")
writeline("{")
tabs += 1
for mthd in jfile["client_methods"]:
  writeline(method_proto(mthd, False) + ";")
tabs -= 1
writeline("}")
whitespace()

#
# Server Interface
#
writeline("public interface IServerPlayer")
writeline("{")
tabs += 1
for mthd in jfile["server_methods"]:
  writeline(method_proto(mthd, False) + ";")
tabs -= 1
writeline("}")
whitespace()


#
# Client IServerPlayer implementation
#
writeline("public partial class RemoteServerPlayer : IServerPlayer")
writeline("{")
tabs += 1
# Fields
writeline("int retSeq;");
# Generate
for mthd in jfile["server_methods"]:
  remote_method(mthd, "Server")
tabs -= 1
whitespace()
writeline("}")

#
# Server IClientPlayer implementation
#
writeline("public partial class RemoteClientPlayer : IClientPlayer")
writeline("{")
tabs += 1
# Fields
writeline("int retSeq;");
# Generate
for mthd in jfile["client_methods"]:
  remote_method(mthd, "Client")
tabs -= 1
whitespace()
writeline("}")

#
# Packet Definitions
#
def Packet(mthd, classname):
  global tabs
  whitespace()
  writeline("public class " + classname + " : IPacket");
  writeline("{")
  tabs += 1
  # Fields
  if "return" in mthd:
    writeline("public int Sequence;")
  if "args" in mthd:
    for a in mthd["args"]:
      writeline("public " + a["type"] + " " + a["name"] + ";")
  # Read Packet
  writeline("public static object Read(NetPacketReader message) => new " + classname + "() {")
  tabs += 1
  if "return" in mthd:
    writeline("Sequence = message.GetInt(),")
  if "args" in mthd:
    for a in mthd["args"]:
      writeline(a["name"] + " =  message." + typeMethods[a["type"]] + "(),")
  tabs -= 1
  writeline("};")
  
  # Write Packet
  writeline("public void WriteContents(NetDataWriter message)")
  writeline("{")
  tabs += 1
  if "return" in mthd:
    writeline("message.Put(Sequence);")
  if "args" in mthd:
    for a in mthd["args"]:
      writeline("message.Put(" + a["name"] + ");");
  tabs -= 1
  writeline("}")
  tabs -= 1
  writeline("}")


for mthd in jfile["server_methods"]:
  classname = "ServerPacket_" + mthd["name"]
  Packet(mthd, classname)

for mthd in jfile["client_methods"]:
  classname = "ClientPacket_" + mthd["name"]
  Packet(mthd, classname)

#
# Generated Packets
#
writeline("static class GeneratedProtocol")
writeline("{")
tabs += 1
# Register Packets
writeline("public static void RegisterPackets()")
writeline("{")
tabs += 1
for mthd in jfile["server_methods"]:
  classname = "ServerPacket_" + mthd["name"]
  writeline("Packets.Register<" + classname + ">(" + classname + ".Read);")
for mthd in jfile["client_methods"]:
  classname = "ClientPacket_" + mthd["name"]
  writeline("Packets.Register<" + classname + ">(" + classname + ".Read);")
tabs -= 1
writeline("}")
whitespace()

varidx = 0
def get_varname():
  global varidx
  varidx += 1
  return "_" + str(varidx)

def handle_packet(mthd, classname):
  global tabs
  varname = get_varname()
  writeline("case " + classname + " " + varname + ": {")
  tabs += 1
  if "return" in mthd:
    writestart("var retval = await player." + mthd["name"] + "(")
  else:
    writestart("player." + mthd["name"] + "(")
  tabs += 1
  if "args" in mthd:
    for idx, a in enumerate(mthd["args"]):
      if idx + 1 < len(mthd["args"]):
        write(varname + "." + a["name"] + ",")
      else:
        write(varname + "." + a["name"])
  tabs -= 1
  writeend(");")
  if "return" in mthd:
    writeline("res.Respond_" + mthd["return"] + "(" + varname + ".Sequence, retval);");
  writeline("return true;")
  tabs -= 1
  writeline("}")
  
# Server Handler
writeline("public static async Task<bool> HandleServerPacket(IPacket pkt, IServerPlayer player, INetResponder res)")
writeline("{")
tabs += 1
writeline("switch (pkt)")
writeline("{")
tabs += 1
for mthd in jfile["server_methods"]:
  classname = "ServerPacket_" + mthd["name"]
  handle_packet(mthd, classname)
  
tabs -= 1
writeline("}")
writeline("return false;")
tabs -= 1
writeline("}")
whitespace()


varidx = 0
# Client Handler
writeline("public static async Task<bool> HandleClientPacket(IPacket pkt, IClientPlayer player, INetResponder res)")
writeline("{")
tabs += 1
writeline("switch (pkt)")
writeline("{")
tabs += 1
for mthd in jfile["client_methods"]:
  classname = "ClientPacket_" + mthd["name"]
  handle_packet(mthd, classname)
  
tabs -= 1
writeline("}")
writeline("return false;")
tabs -= 1
writeline("}")
whitespace()



tabs -= 1
writeline("}")

#end file

tabs -= 1
writeline("}")
