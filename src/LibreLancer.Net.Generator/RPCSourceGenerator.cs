using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis;

namespace LibreLancer.Net.Generator;

/// <summary>
/// A sample source generator that creates C# classes based on the text file (in this case, Domain Driven Design ubiquitous language registry).
/// When using a simple text file as a baseline, we can create a non-incremental source generator.
/// </summary>
[Generator]
public class RPCSourceGenerator : ISourceGenerator
{
    private const string PacketReaderClass = "LibreLancer.Net.Protocol.PacketReader";
    private const string PacketWriterClass = "LibreLancer.Net.Protocol.PacketWriter";
    private const string IPacket = "LibreLancer.Net.Protocol.IPacket";
    private const string TaskCompletionSourceClass = "System.Threading.Tasks.TaskCompletionSource";
    private const string TaskClass = "System.Threading.Tasks.Task";
    private const string IPacketSender = "LibreLancer.Net.IPacketSender";
    private const string NetResponseHandler = "LibreLancer.Net.Protocol.RpcPackets.NetResponseHandler";

    private List<string> allPackets = new List<string>();
    private List<string> allMethods = new List<string>();
    private HashSet<string> generatedResponses = new HashSet<string>();

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new RPCInterfaceSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var receiver = (RPCInterfaceSyntaxReceiver) context.SyntaxReceiver;

        foreach (var interfaceDeclaration in receiver.Candidates)
        {
            var model = context.Compilation.GetSemanticModel(interfaceDeclaration.SyntaxTree, true);
            var type = ModelExtensions.GetDeclaredSymbol(model, interfaceDeclaration) as ITypeSymbol;
            GenerateImplementation(type, ref context);
        }
        GenerateResponseHandler(ref context);


        var writer = new TabbedWriter();
        writer.AppendLine("// <auto-generated>");
        writer.AppendLine("// ReSharper disable All");
        writer.AppendLine("namespace LibreLancer.Net.Protocol.RpcPackets;");
        writer.AppendLine("public partial class GeneratedProtocol");
        writer.AppendLine("{");
        writer.Indent();
        allMethods.Sort();
        writer.AppendLine($"public const string PROTOCOL_HASH=\"{ProtocolHash.Hash(allMethods)}\";");
        writer.AppendLine("public static void RegisterPackets()");
        writer.AppendLine("{").Indent();
        foreach (var p in allPackets)
        {
            writer.AppendLine($"LibreLancer.Net.Protocol.Packets.Register<{p}>({p}.Read);");
        }
        writer.UnIndent().AppendLine("}");
        writer.UnIndent();
        writer.AppendLine("}");
        context.AddSource("GeneratedProtocol_Packets.g.cs", writer.ToString());
    }

    void GenerateResponseHandler(ref GeneratorExecutionContext context)
    {
        var writer = new TabbedWriter();
        writer.AppendLine("// <auto-generated>");
        writer.AppendLine("// ReSharper disable All");
        writer.AppendLine("namespace LibreLancer.Net.Protocol.RpcPackets;");
        writer.AppendLine("public partial class NetResponseHandler");
        writer.AppendLine("{").Indent();
        writer.AppendLine("int retSeq;");
        writer.AppendLine("private System.Collections.Generic.Dictionary<int, object> completionSources = new ();");
        writer.AppendLine("public int NextSequence() => System.Threading.Interlocked.Increment(ref retSeq);");
        foreach (var type in generatedResponses)
        {
            writer.AppendLine($"public {TaskCompletionSourceClass}<{type}> {ResponseHandler(type)}(int sequence)");
            writer.AppendLine("{").Indent();
            writer.AppendLine($"var src = new {TaskCompletionSourceClass}<{type}>();");
            writer.AppendLine("completionSources.Add(sequence, src);");
            writer.AppendLine("return src;");
            writer.UnIndent().AppendLine("}");
        }

        writer.AppendLine($"public bool HandlePacket({IPacket} packet)");
        writer.AppendLine("{").Indent();
        writer.AppendLine("switch (packet)");
        writer.AppendLine("{").Indent();
        int i = 0;
        foreach (var type in generatedResponses)
        {
            var packetName = $"LibreLancer.Net.Protocol.RpcPackets.ResponsePacket_{type.Replace(".", "_")}";
            var pkName = $"_{i++}";
            writer.AppendLine($"case {packetName} {pkName}:");
            writer.AppendLine("{").Indent();
            writer.AppendLine($"if (completionSources.TryGetValue({pkName}.Sequence, out object k)) {{").Indent();
            writer.AppendLine($"completionSources.Remove({pkName}.Sequence);");
            writer.AppendLine($"if (k is {TaskCompletionSourceClass}<{type}> i) i.SetResult({pkName}.Value);");
            writer.UnIndent().AppendLine("}");
            writer.AppendLine("return true;");
            writer.UnIndent().AppendLine("}");
        }
        writer.AppendLine("default:");
        writer.Indent().AppendLine("return false;").UnIndent();
        writer.UnIndent().AppendLine("}");
        writer.UnIndent().AppendLine("}");
        writer.UnIndent().AppendLine("}");
        context.AddSource("NetResponseHandler.g.cs", writer.ToString());
    }

    string ResponseHandler(string fullName) => $"GetCompletionSource_{fullName.Replace(".", "_")}";

    void GeneratePackets(ITypeSymbol src, ref GeneratorExecutionContext context)
    {
        var writer = new TabbedWriter();
        writer.AppendLine("// <auto-generated>");
        string ns;
        if (src.ContainingNamespace != null)
            ns = src.ContainingNamespace.ToDisplayString() + ".RpcPackets";
        else
            ns = "RpcPackets";
        writer.AppendLine($"namespace {ns};").AppendLine();
        foreach (var member in src.GetMembers())
        {
            if (member is not IMethodSymbol method)
                continue;
            var packetName = $"{src.Name}_{method.Name}Packet";
            writer.AppendLine($"class {packetName} : {IPacket}");
            writer.AppendLine("{").Indent();
            if (!method.ReturnsVoid)
                writer.AppendLine("public int Sequence;");
            foreach (var param in method.Parameters)
                writer.AppendLine($"public {param.Type.ToDisplayString()} {param.Name};");
            writer.AppendLine($"public static object Read({PacketReaderClass} inPacket)");
            writer.AppendLine("{").Indent();
            writer.AppendLine($"var _packet = new {packetName}();");
            if (!method.ReturnsVoid)
                writer.AppendLine("_packet.Sequence = inPacket.GetVariableInt32();");
            foreach (var param in method.Parameters)
                writer.AppendLine(ReadField(param.Name, param.Type));
            writer.AppendLine("return _packet;");
            writer.UnIndent().AppendLine("}");
            writer.AppendLine($"public void WriteContents({PacketWriterClass} outPacket)");
            writer.AppendLine("{").Indent();
            if (!method.ReturnsVoid)
                writer.AppendLine("outPacket.PutVariableInt32(Sequence);");
            foreach (var param in method.Parameters)
                writer.AppendLine(PutField(param.Name, param.Type));
            writer.UnIndent().AppendLine("}");
            writer.UnIndent().AppendLine("}");
            allPackets.Add($"{ns}.{packetName}");

            var desc = new StringBuilder();
            desc.AppendLine(src.Name);
            desc.AppendLine(method.Name);
            desc.AppendLine(method.ReturnType.ToDisplayString());
            foreach (var p in method.Parameters)
            {
                desc.AppendLine(p.Name);
                desc.AppendLine(p.Type.ToDisplayString());
            }
            allMethods.Add(desc.ToString());
        }
        context.AddSource(src.Name + "_Packets.g.cs", writer.ToString());
    }

    void GenerateRemoteImpl(ITypeSymbol src, ref GeneratorExecutionContext context)
    {
        var writer = new TabbedWriter();
        writer.AppendLine("// <auto-generated>");
        string packetsName;
        if (src.ContainingNamespace != null)
        {
            writer.AppendLine($"namespace {src.ContainingNamespace.ToDisplayString()};");
            packetsName = src.ContainingNamespace.ToDisplayString() + $".RpcPackets.{src.Name}_";
        }
        else
        {
            packetsName = $"RpcPackets.{src.Name}_";
        }

        var newName = "Remote" + src.Name.Substring(1);
        writer.AppendLine($"public partial class {newName}: {src.ToDisplayString()}");
        writer.AppendLine("{").Indent();

        writer.AppendLine($"public {IPacketSender} Sender;");
        writer.AppendLine($"public {NetResponseHandler} ResponseHandler;");

        writer.AppendLine($"public {newName}({IPacketSender} sender, {NetResponseHandler} responseHandler)");
        writer.AppendLine("{").Indent();
        writer.AppendLine("Sender = sender;");
        writer.AppendLine("ResponseHandler = responseHandler;");
        writer.UnIndent().AppendLine("}");

        writer.AppendLine($"private void SendPacket({IPacket} packet, int channel)");
        writer.AppendLine("{").Indent();
        writer.AppendLine("Sender.SendPacket(packet, LibreLancer.Net.PacketDeliveryMethod.ReliableOrdered + channel);");
        writer.UnIndent().AppendLine("}");

        foreach (var member in src.GetMembers())
        {
            if (member is not IMethodSymbol method)
                continue;
            int channel = 0;
            foreach (var att in method.GetAttributes())
            {
                if (att.AttributeClass?.Name == "ChannelAttribute")
                {
                    channel = (int) (att.ConstructorArguments[0].Value ?? 0);
                    break;
                }
            }
            string ret = method.ReturnsVoid ? "void" : method.ReturnType.ToDisplayString();
            if (ret != "void" && !ret.StartsWith("System.Threading.Tasks.Task"))
                throw new Exception("Invalid return type for RPC");
            writer.Append($"public {ret} {method.Name}(");
            writer.Append(string.Join(", ", method.Parameters.Select(x =>
                $"{x.Type.ToDisplayString()} {x.Name}")));
            writer.AppendLine(")");
            writer.AppendLine("{").Indent();
            if (!method.ReturnsVoid)
            {
                writer.AppendLine("var Sequence = ResponseHandler.NextSequence();");
                var type = ((INamedTypeSymbol) method.ReturnType).TypeArguments[0];
                GenerateResponsePacket(type, ref context);
                writer.AppendLine(
                    $"var _completion = ResponseHandler.GetCompletionSource_{type.ToDisplayString().Replace(".", "_")}(Sequence);");
            }
            writer.AppendLine($"SendPacket(new {packetsName}{method.Name}Packet() {{").Indent();
            if (!method.ReturnsVoid) writer.AppendLine("Sequence = Sequence,");
            foreach (var p in method.Parameters)
                writer.AppendLine($"{p.Name} = {p.Name},");
            writer.UnIndent().AppendLine($"}}, {channel});");
            if (!method.ReturnsVoid)
                writer.AppendLine("return _completion.Task;");
            writer.UnIndent().AppendLine("}");

        }
        writer.UnIndent().AppendLine("}");
        context.AddSource(newName + ".g.cs", writer.ToString());
    }

    void GenerateHandler(ITypeSymbol src, ref GeneratorExecutionContext context)
    {
        var writer = new TabbedWriter();
        string packetsName;
        if (src.ContainingNamespace != null)
        {
            packetsName = src.ContainingNamespace.ToDisplayString() + $".RpcPackets.{src.Name}_";
        }
        else
        {
            packetsName = $"RpcPackets.{src.Name}_";
        }
        writer.AppendLine("// <auto-generated>");
        writer.AppendLine("// ReSharper disable All");
        writer.AppendLine("namespace LibreLancer.Net.Protocol.RpcPackets;");
        writer.AppendLine("public partial class GeneratedProtocol");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine($"public static async {TaskClass}<bool> Handle{src.Name}({IPacket} packet, {src.ToDisplayString()} instance, {IPacketSender} responder)");
        writer.AppendLine("{").Indent();
        writer.AppendLine("switch (packet)");
        writer.AppendLine("{").Indent();
        int i = 0;
        foreach (var member in src.GetMembers())
        {
            if (member is not IMethodSymbol method)
                continue;
            var pkName = $"_{i++}";
            writer.AppendLine($"case {packetsName}{method.Name}Packet {pkName}:");
            writer.AppendLine("{").Indent();
            if (!method.ReturnsVoid)
                writer.Append("var result = await ");
            writer.Append($"instance.{method.Name}(");
            writer.Append(string.Join(", ", method.Parameters.Select(x => $"{pkName}.{x.Name}")));
            writer.AppendLine(");");
            if (!method.ReturnsVoid) {
                var type = ((INamedTypeSymbol) method.ReturnType).TypeArguments[0];
                writer.AppendLine(
                    $"var response = new LibreLancer.Net.Protocol.RpcPackets.ResponsePacket_{type.ToDisplayString().Replace(".", "_")}();");
                writer.AppendLine($"response.Sequence = {pkName}.Sequence;");
                writer.AppendLine("response.Value = result;");
                writer.AppendLine(
                    "responder.SendPacket(response, LibreLancer.Net.PacketDeliveryMethod.ReliableOrdered);");
            }
            writer.AppendLine("return true;");
            writer.UnIndent().AppendLine("}");
        }

        writer.AppendLine("default:");
        writer.Indent().AppendLine("return false;").UnIndent();
        writer.UnIndent().AppendLine("}");
        writer.UnIndent().AppendLine("}");
        writer.UnIndent();
        writer.AppendLine("}");
        context.AddSource($"GeneratedProtocol_{src.Name}.g.cs", writer.ToString());
    }

    void GenerateImplementation(ITypeSymbol src, ref GeneratorExecutionContext context)
    {
        GeneratePackets(src, ref context);
        GenerateRemoteImpl(src, ref context);
        GenerateHandler(src, ref context);
    }


    void GenerateResponsePacket(ITypeSymbol type, ref GeneratorExecutionContext context)
    {
        var fullName = type.ToDisplayString();
        var packetName = "ResponsePacket_" + fullName.Replace(".", "_");
        if (generatedResponses.Contains(fullName))
            return;
        generatedResponses.Add(fullName);
        allPackets.Add("LibreLancer.Net.Protocol.RpcPackets." + packetName);
        var source = $@"
// <auto-generated>
// ReSharper disable All
namespace LibreLancer.Net.Protocol.RpcPackets;

class {packetName} : {IPacket}
{{
    public int Sequence;
    public {fullName} Value;
    public static object Read(PacketReader inPacket)
    {{
        var _packet = new {packetName}();
        _packet.Sequence = inPacket.GetVariableInt32();
        {ReadField("Value", type)}
        return _packet;
    }}
    public void WriteContents(PacketWriter outPacket)
    {{
        outPacket.PutVariableInt32(Sequence);
        {PutField("Value", type)}
    }}
}}";
        context.AddSource(packetName + ".g.cs", source);
    }

    private static Dictionary<string, string> typeMethods = new()
    {
        {"int" , "GetVariableInt32"},
        {"System.Numerics.Quaternion" , "GetQuaternion"},
        {"System.Numerics.Vector3" , "GetVector3"},
        {"byte" , "GetByte"},
        {"sbyte" , "GetSByte"},
        {"double" , "GetDouble"},
        {"float" , "GetFloat"},
        {"long" , "GetVariableInt64"},
        {"System.Net.IPEndPoint" , "GetNetEndPoint"},
        {"short" , "GetShort"},
        {"string" , "GetString"},
        {"uint" , "GetUInt"},
        {"ulong" , "GetVariableUInt64"},
        {"ushort" , "GetUShort"},
        {"bool" , "GetBool"},
        {"LibreLancer.World.ObjectName", "GetObjectName"}
    };

    private static Dictionary<string, string> encodeMethods = new()
    {
        {"int", "PutVariableInt32" },
        {"long", "PutVariableInt64" },
        {"ulong", "PutVariableUInt64" },
    };

    string ReadField(string name, ITypeSymbol type)
    {
        if (type.TypeKind == TypeKind.Array)
        {
            var element = ((IArrayTypeSymbol) type).ElementType;
            return @$"
            uint __len_{name} = inPacket.GetVariableUInt32();
            if (__len_{name} > 0) {{
                _packet.{name} = new {element.ToDisplayString()}[(int)(__len_{name} - 1)];
                for(int __idx = 0; __idx < _packet.{name}.Length; __idx++)
                    _packet.{name}[__idx] = {ReadScalar(element)};
            }}";
        }
        else
        {
            return $"_packet.{name} = {ReadScalar(type)};";
        }
    }

    string ReadScalar(ITypeSymbol type)
    {
        if (typeMethods.TryGetValue(type.ToDisplayString(), out var method))
            return $"inPacket.{method}()";
        else if (type.TypeKind == TypeKind.Enum)
            return $"({type.ToDisplayString()})inPacket.GetVariableInt32()";
        else
            return $"{type.ToDisplayString()}.Read(inPacket)";
    }

    string PutField(string name, ITypeSymbol type)
    {
        var fullName = type.ToDisplayString();
        if (type.TypeKind == TypeKind.Array)
        {
            var element = ((IArrayTypeSymbol) type).ElementType;
            return @$"
            if({name} != null) {{
                outPacket.PutVariableUInt32((uint)({name}.Length + 1));
                for(int __idx = 0; __idx < {name}.Length; __idx++)
                    {PutScalar($"{name}[__idx]", element)}
            }}
            else
                outPacket.PutVariableUInt32(0);
            ";
        }
        else
            return PutScalar(name, type);
    }

    string PutScalar(string name, ITypeSymbol type)
    {
        if (encodeMethods.TryGetValue(type.ToDisplayString(), out var method))
            return $"outPacket.{method}({name});";
        else if (typeMethods.ContainsKey(type.ToDisplayString()))
            return $"outPacket.Put({name});";
        else if (type.TypeKind == TypeKind.Enum)
            return $"outPacket.PutVariableInt32((int){name});";
        else
            return $"{name}.Put(outPacket);";
    }


}
